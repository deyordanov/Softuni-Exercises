public class Solution {
  public int NetworkDelayTime(int[][] times, int n, int k) {
    Dictionary < int, List < Edge >> edges = new Dictionary < int, List < Edge >> ();
    double[] distances = new double[n + 1];
    HashSet < int > visited = new HashSet < int > ();

    foreach(int[] time in times) {
      int from = time[0];
      int to = time[1];
      int weight = time[2];

      edges.TryAdd(from, new List < Edge > ());
      edges.TryAdd(to, new List < Edge > ());

      edges[from].Add(new Edge(from, to, weight));
    }

    Array.Fill(distances, double.PositiveInfinity);
    distances[k] = 0;

    BFS(k, distances, visited, edges);

    if (visited.Count != n) {
      return -1;
    }

    return (int) distances
      .Where(d => !double.IsPositiveInfinity(d))
      .Max();
  }

  void BFS(int k, double[] distances, HashSet < int > visited, Dictionary < int, List < Edge >> edges) {
    PriorityQueue < int, double > priorityQueue = new PriorityQueue < int, double > ();
    priorityQueue.Enqueue(k, distances[k]);

    while (priorityQueue.Count > 0) {
      int parent = priorityQueue.Dequeue();

      //Additional check for a cycle.
      // if (visited.Contains(parent))
      // {
      //     break;
      // }

      visited.Add(parent);

      foreach(Edge edge in edges[parent]) {
        int child = edge.To;

        if (double.IsPositiveInfinity(distances[child])) {
          priorityQueue.Enqueue(child, distances[child]);
        }

        double distance = distances[parent] + edge.Weight;

        if (distance < distances[child]) {
          distances[child] = distance;
          priorityQueue.Enqueue(child, distances[child]);
        }
      }
    }
  }
}

class Edge {
  public Edge(
    int from,
    int to,
    int weight) {
    this.From = from;
    this.To = to;
    this.Weight = weight;
  }
  public int From {
    get;
    set;
  }

  public int To {
    get;
    set;
  }

  public int Weight {
    get;
    set;
  }
}