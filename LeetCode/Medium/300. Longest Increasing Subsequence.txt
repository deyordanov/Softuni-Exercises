public class Solution {
    public int LengthOfLIS(int[] nums) {
        IList<int> lis = new List<int>();
        lis.Add(nums[0]);
        for(int i = 1; i < nums.Length; i++)
        {
            if(nums[i] > lis.Last())
            {
                lis.Add(nums[i]);
            }
            else
            {
		// Replace the smallest element that is equal to or greater than the current element - this way we ensures that the LIS 		remains accurate and represent the LIS encountered so far.
                int index = this.BinarySearch(lis, nums[i]);
                lis[index] = nums[i];
            }
        }

        return lis.Count;
    }

    private int BinarySearch(IList<int> lis, int numberToFind)
    {
        int leftIndex = 0;
        int rightIndex = lis.Count - 1;
        int middleIndex = -1;
        while(leftIndex < rightIndex)
        {
            middleIndex = (leftIndex + rightIndex) / 2;
            if(lis[middleIndex] == numberToFind)
            {
                return middleIndex;
            }
            else if(lis[middleIndex] < numberToFind)
            {
                leftIndex = middleIndex + 1;
            }
            else
            {
                rightIndex = middleIndex;
            }
        }

        return leftIndex;
    }
}