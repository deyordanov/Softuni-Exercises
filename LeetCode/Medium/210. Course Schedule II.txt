public class Solution {
  public int[] FindOrder(int numCourses, int[][] prerequisites) {
    Dictionary < int, List < int >> graph = new Dictionary < int, List < int >> ();
    HashSet < int > visited = new HashSet < int > ();
    HashSet < int > cycle = new HashSet < int > ();
    Stack < int > elements = new Stack < int > ();

    for (int i = 0; i < numCourses; i++) {
      graph.TryAdd(i, new List < int > ());
    }

    foreach(int[] prerequisite in prerequisites) {
      int parent = prerequisite[1];
      int child = prerequisite[0];

      graph[parent].Add(child);
    }

    foreach(int parent in graph.Keys) {
      if (visited.Contains(parent)) {
        continue;
      }

      bool result = DFS(parent, graph, cycle, visited, elements);

      if (!result) {
        return new int[0];
      }
    }

    return elements.Count == 0 ? graph.Keys.ToArray() : elements.ToArray();
  }

  bool DFS(
    int parent,
    Dictionary < int, List < int >> graph,
    HashSet < int > cycle,
    HashSet < int > visited,
    Stack < int > elements) {
    if (cycle.Contains(parent)) {
      return false;
    }

    if (visited.Contains(parent)) {
      return true;
    }

    cycle.Add(parent);
    visited.Add(parent);

    foreach(int child in graph[parent]) {
      if (!DFS(child, graph, cycle, visited, elements)) {
        return false;
      }
    }

    cycle.Remove(parent);
    elements.Push(parent);

    return true;
  }
}